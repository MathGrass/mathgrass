{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this Project MathGrass MathGrass ( Math ematical Gr aph Ass essment ) is a web application that brings automatic assessment to the realm of mathematical graphs. Its core functionality is the definition of graphs and tasks, which the system presents to participants. Tasks consist of form-based questions, graphical labeling, or questions which trigger the execution of a instructor-specified SageMath script. The participants can then interact with the graph in a graph viewer and try to answer the posed questions. Upon requesting an assessment of the individual answers, the assessment server evaluates the participants' answers and returns the results to the users. Furthermore, MathGrass supports incremental hints, which simulate instructor assistance and can support the learning experience. How to Read This Documentation This documentation contains the set of features that MathGrass provides, information about the usage for either instructors or students. Furthermore, there are notes about the deployment of a MathGrass instance and a developer documentation .","title":"About this Project"},{"location":"#about-this-project","text":"","title":"About this Project"},{"location":"#mathgrass","text":"MathGrass ( Math ematical Gr aph Ass essment ) is a web application that brings automatic assessment to the realm of mathematical graphs. Its core functionality is the definition of graphs and tasks, which the system presents to participants. Tasks consist of form-based questions, graphical labeling, or questions which trigger the execution of a instructor-specified SageMath script. The participants can then interact with the graph in a graph viewer and try to answer the posed questions. Upon requesting an assessment of the individual answers, the assessment server evaluates the participants' answers and returns the results to the users. Furthermore, MathGrass supports incremental hints, which simulate instructor assistance and can support the learning experience.","title":"MathGrass"},{"location":"#how-to-read-this-documentation","text":"This documentation contains the set of features that MathGrass provides, information about the usage for either instructors or students. Furthermore, there are notes about the deployment of a MathGrass instance and a developer documentation .","title":"How to Read This Documentation"},{"location":"deployment/","text":"Deployment tba","title":"Deployment"},{"location":"deployment/#deployment","text":"tba","title":"Deployment"},{"location":"developer_guide/architecture/","text":"Architecture The API and the Evaluator use RabbitMQ as a message bus to pass messages.","title":"Architecture"},{"location":"developer_guide/architecture/#architecture","text":"The API and the Evaluator use RabbitMQ as a message bus to pass messages.","title":"Architecture"},{"location":"developer_guide/openapi/","text":"OpenAPI Specification for MathGrass File Can be found in the backend project under mathgrass-api/openapi-spec/graphex-minimal.yaml Endpoints In the beginning of the file DTOs In the end of the file","title":"OpenAPI Specification for MathGrass"},{"location":"developer_guide/openapi/#openapi-specification-for-mathgrass","text":"","title":"OpenAPI Specification for MathGrass"},{"location":"developer_guide/openapi/#file","text":"Can be found in the backend project under mathgrass-api/openapi-spec/graphex-minimal.yaml","title":"File"},{"location":"developer_guide/openapi/#endpoints","text":"In the beginning of the file","title":"Endpoints"},{"location":"developer_guide/openapi/#dtos","text":"In the end of the file","title":"DTOs"},{"location":"developer_guide/quickstart/","text":"Quickstart Requirements Make sure that you have JDK>=17, Gradle, Docker, docker-compose, node>=18.12.0 with npm, and Python>=3.10 installed. Set Up Your Development Environment Clone the projects for the frontend , the API Project , and the evaluator project Start the dependencies of the API and the evaluator(PostGres & RabbitMQ) either manually or the provided docker compose project via docker-compose -f mathgrass-backend-infrastructure.yaml up -d in the folder mathgrass-server/api/docker Import the gradle project under mathgrass-api into your favorite Java IDE and run the application (entrypoint: MathgrassServerApplication.java ) with the Spring profile demodata (or not, if no demodata should be present). Import the React project under mathgrass-frontend into your favorite TypeScript IDE and run npm install && npm run start You can check whether the project has build correctly by checking the following paths on localhost: Swagger UI (http://localhost:8080/swagger-ui/) Frontend (http://localhost:3000)","title":"Quickstart"},{"location":"developer_guide/quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"developer_guide/quickstart/#requirements","text":"Make sure that you have JDK>=17, Gradle, Docker, docker-compose, node>=18.12.0 with npm, and Python>=3.10 installed.","title":"Requirements"},{"location":"developer_guide/quickstart/#set-up-your-development-environment","text":"Clone the projects for the frontend , the API Project , and the evaluator project Start the dependencies of the API and the evaluator(PostGres & RabbitMQ) either manually or the provided docker compose project via docker-compose -f mathgrass-backend-infrastructure.yaml up -d in the folder mathgrass-server/api/docker Import the gradle project under mathgrass-api into your favorite Java IDE and run the application (entrypoint: MathgrassServerApplication.java ) with the Spring profile demodata (or not, if no demodata should be present). Import the React project under mathgrass-frontend into your favorite TypeScript IDE and run npm install && npm run start You can check whether the project has build correctly by checking the following paths on localhost: Swagger UI (http://localhost:8080/swagger-ui/) Frontend (http://localhost:3000)","title":"Set Up Your Development Environment"},{"location":"developer_guide/backend/API_Implementation/","text":"API Implementation The API relies on generated interfaces based on the OpenAPI specification The Gradle task generateApi needs to be executed before being able to run the project When the API is started the swagger UI is available at http://localhost:8080/swagger-ui.html API und DB models are transformed to each other by classes that inherit from ModelTransformer under src/main/java/de/tudresden/inf/st/mathgrassserver/transform Endpoints are described in OpenAPI specification","title":"API Implementation"},{"location":"developer_guide/backend/API_Implementation/#api-implementation","text":"The API relies on generated interfaces based on the OpenAPI specification The Gradle task generateApi needs to be executed before being able to run the project When the API is started the swagger UI is available at http://localhost:8080/swagger-ui.html API und DB models are transformed to each other by classes that inherit from ModelTransformer under src/main/java/de/tudresden/inf/st/mathgrassserver/transform Endpoints are described in OpenAPI specification","title":"API Implementation"},{"location":"developer_guide/backend/concepts/","text":"Concepts & Domain DTO Model Generated by swagger codegen spec (see openapi-spec/graphex-minimal.yaml ) Entity Relationship Diagram (used in DB) Model Breakdown For better understanding of the model, we will break it down into a few parts: Task A Task describes a fully defined task on solving a problem on a certain graph. In order to distinguish between static tasks and dynamic tasks a task can (but does not necessarily have to) contain a TaskTemplate . If it contains a TaskTemplate, it can be considered a dynamic task otheriwse it's a static one (which is associated to a static answer string). A task template can be used in multiple tasks and it's purpose is providing the same exercise (with the same evaluation script) for different tasks (i.e. different graphs). This way the teacher can create one general task description, which can be associated with different graphs. For managing evaluation scripts there is the TaskSolver Students can submit Feedback for tasks. This feedback is not evaluated by the system, but can be used by the teacher to improve the task description. Teachers can setup TaskHints for tasks. These hints are shown to the student if he/she requests them individually. To group and categorize tasks, they can be put into TaskGroups and TaskCollections . A task can be part of multiple groups and collections. Graph Entities like Graph , Vertex and Edge obviuosly represent the graph data structure. Tags Tags can be used to categorize tasks and graphs. They are used in the frontend to filter task templates and graphs. TaskResult As soon as a student submits a solution to the API it gets recorded as a TaskResult in the database. After the solution has been checked/evaluated (using the static answer or the Evaluator service) the attribute answerTrue is written so that the TaskResult is complete.","title":"Concepts & Domain"},{"location":"developer_guide/backend/concepts/#concepts-domain","text":"","title":"Concepts &amp; Domain"},{"location":"developer_guide/backend/concepts/#dto-model","text":"Generated by swagger codegen spec (see openapi-spec/graphex-minimal.yaml )","title":"DTO Model"},{"location":"developer_guide/backend/concepts/#entity-relationship-diagram-used-in-db","text":"","title":"Entity Relationship Diagram (used in DB)"},{"location":"developer_guide/backend/concepts/#model-breakdown","text":"For better understanding of the model, we will break it down into a few parts:","title":"Model Breakdown"},{"location":"developer_guide/backend/concepts/#task","text":"A Task describes a fully defined task on solving a problem on a certain graph. In order to distinguish between static tasks and dynamic tasks a task can (but does not necessarily have to) contain a TaskTemplate . If it contains a TaskTemplate, it can be considered a dynamic task otheriwse it's a static one (which is associated to a static answer string). A task template can be used in multiple tasks and it's purpose is providing the same exercise (with the same evaluation script) for different tasks (i.e. different graphs). This way the teacher can create one general task description, which can be associated with different graphs. For managing evaluation scripts there is the TaskSolver Students can submit Feedback for tasks. This feedback is not evaluated by the system, but can be used by the teacher to improve the task description. Teachers can setup TaskHints for tasks. These hints are shown to the student if he/she requests them individually. To group and categorize tasks, they can be put into TaskGroups and TaskCollections . A task can be part of multiple groups and collections.","title":"Task"},{"location":"developer_guide/backend/concepts/#graph","text":"Entities like Graph , Vertex and Edge obviuosly represent the graph data structure.","title":"Graph"},{"location":"developer_guide/backend/concepts/#tags","text":"Tags can be used to categorize tasks and graphs. They are used in the frontend to filter task templates and graphs.","title":"Tags"},{"location":"developer_guide/backend/concepts/#taskresult","text":"As soon as a student submits a solution to the API it gets recorded as a TaskResult in the database. After the solution has been checked/evaluated (using the static answer or the Evaluator service) the attribute answerTrue is written so that the TaskResult is complete.","title":"TaskResult"},{"location":"developer_guide/backend/evaluator/","text":"Evaluator (Python) The Evaluator is a direct member of the Top Level Architecture and can be considered a microservice. It is responsible for the evaluation of submitted task solutions which are transferred by the API over the message bus. For isolation purposes it uses docker containers as computing instances for the actual evaluation process. Since the main purpose of this application is to evaluate mathematical tasks (especially tasks about graphs) every docker container used here is based on the Sage Math docker image. The basic configuration uses the BasicEvaluator (see below) in order to describe the procedure of the current evaluation process. Docker Manager ( docker_manager.py and docker_container.py ) The Docker Manager keeps track of allocated and free docker containers. Besided the preparation of the containers in advance it also removes them after they finished their respective evaluation request. As a result a docker container is only used for a single task solution evaluation. The reason behind that lays in the desired degree of isolation. In order to decrease latency when doing so it is possible to specify a constant which descibes how many docker containers should be prepared in advance. Also a maximum can be declared but if this limit is reached further requests will be discared for now. AbstractEvaluator ( abstract_evaluator.py ) The AbstractEvaluator contains an interface in order enable the implementation of different evaluation procedures. It is kept lean: First, every sub instance of the AbstractEvaluator can declare the name of the message bus queue which it will receive requests from. And second it defines a callback which is invoked when the evaluator receives a message from the selected queue. BasicEvaluator ( basic_evaluator.py ) Once the basic evaluator receives an evaluation request (containing a request id, a taks id and the submitted soluation) it will trigger a bunch of steps. These consist of the following: - allocating a container using the docker manager - loading the graph as well as the evaluation script from the database using the task id - base64 encoding the just loaded graph and the submitted solution - uploading the script as a file (named eval.sage) - executing the script in the container with command sage eval.sage <answer-as-base64> <graph-as-base64>","title":"Evaluator (Python)"},{"location":"developer_guide/backend/evaluator/#evaluator-python","text":"The Evaluator is a direct member of the Top Level Architecture and can be considered a microservice. It is responsible for the evaluation of submitted task solutions which are transferred by the API over the message bus. For isolation purposes it uses docker containers as computing instances for the actual evaluation process. Since the main purpose of this application is to evaluate mathematical tasks (especially tasks about graphs) every docker container used here is based on the Sage Math docker image. The basic configuration uses the BasicEvaluator (see below) in order to describe the procedure of the current evaluation process.","title":"Evaluator (Python)"},{"location":"developer_guide/backend/evaluator/#docker-manager-docker_managerpy-and-docker_containerpy","text":"The Docker Manager keeps track of allocated and free docker containers. Besided the preparation of the containers in advance it also removes them after they finished their respective evaluation request. As a result a docker container is only used for a single task solution evaluation. The reason behind that lays in the desired degree of isolation. In order to decrease latency when doing so it is possible to specify a constant which descibes how many docker containers should be prepared in advance. Also a maximum can be declared but if this limit is reached further requests will be discared for now.","title":"Docker Manager (docker_manager.py and docker_container.py)"},{"location":"developer_guide/backend/evaluator/#abstractevaluator-abstract_evaluatorpy","text":"The AbstractEvaluator contains an interface in order enable the implementation of different evaluation procedures. It is kept lean: First, every sub instance of the AbstractEvaluator can declare the name of the message bus queue which it will receive requests from. And second it defines a callback which is invoked when the evaluator receives a message from the selected queue.","title":"AbstractEvaluator (abstract_evaluator.py)"},{"location":"developer_guide/backend/evaluator/#basicevaluator-basic_evaluatorpy","text":"Once the basic evaluator receives an evaluation request (containing a request id, a taks id and the submitted soluation) it will trigger a bunch of steps. These consist of the following: - allocating a container using the docker manager - loading the graph as well as the evaluation script from the database using the task id - base64 encoding the just loaded graph and the submitted solution - uploading the script as a file (named eval.sage) - executing the script in the container with command sage eval.sage <answer-as-base64> <graph-as-base64>","title":"BasicEvaluator (basic_evaluator.py)"},{"location":"developer_guide/backend/prerequisites/","text":"Prerequisites & Requirements Message Bus Dependencies Rabbit MQ Database Dependencies Postgres Evaluator Dependencies Docker Python 3 API Dependencies Java 11 IntelliJ (recommended)","title":"Prerequisites & Requirements"},{"location":"developer_guide/backend/prerequisites/#prerequisites-requirements","text":"","title":"Prerequisites &amp; Requirements"},{"location":"developer_guide/backend/prerequisites/#message-bus","text":"","title":"Message Bus"},{"location":"developer_guide/backend/prerequisites/#dependencies","text":"Rabbit MQ","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#database","text":"","title":"Database"},{"location":"developer_guide/backend/prerequisites/#dependencies_1","text":"Postgres","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#evaluator","text":"","title":"Evaluator"},{"location":"developer_guide/backend/prerequisites/#dependencies_2","text":"Docker Python 3","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#api","text":"","title":"API"},{"location":"developer_guide/backend/prerequisites/#dependencies_3","text":"Java 11 IntelliJ (recommended)","title":"Dependencies"},{"location":"developer_guide/backend/troubleshooting/","text":"Troubleshooting Starting the API The API won't start as long as there is no message queue reachable there is no database with speical name (see Development & Operations->Building and Deploying MathGrass->Database) created Starting the evaluator on Mac (especially with M1) If console says something like /opt/homebrew/opt/postgresql/lib/libpq.5.dylib' (no such file) : - run ln -s /opt/homebrew/opt/postgresql/lib/postgresql@14/* /opt/homebrew/opt/postgresql/lib/","title":"Troubleshooting"},{"location":"developer_guide/backend/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"developer_guide/backend/troubleshooting/#starting-the-api","text":"The API won't start as long as there is no message queue reachable there is no database with speical name (see Development & Operations->Building and Deploying MathGrass->Database) created","title":"Starting the API"},{"location":"developer_guide/backend/troubleshooting/#starting-the-evaluator-on-mac-especially-with-m1","text":"If console says something like /opt/homebrew/opt/postgresql/lib/libpq.5.dylib' (no such file) : - run ln -s /opt/homebrew/opt/postgresql/lib/postgresql@14/* /opt/homebrew/opt/postgresql/lib/","title":"Starting the evaluator on Mac (especially with M1)"},{"location":"developer_guide/backend/usage/","text":"How to Use MathGrass General process of MathGrass request/response interactions, basic workflow Launch Pipeline Deploy the components in the following order: Start postgres server Start rabbitmq server Run evaluator Run API Evaluater start with python3 main.py API To run in IntelliJ follow the configuration in Development & Operations->Building and Deploying MathGrass->API","title":"How to Use MathGrass"},{"location":"developer_guide/backend/usage/#how-to-use-mathgrass","text":"General process of MathGrass request/response interactions, basic workflow","title":"How to Use MathGrass"},{"location":"developer_guide/backend/usage/#launch-pipeline","text":"Deploy the components in the following order: Start postgres server Start rabbitmq server Run evaluator Run API","title":"Launch Pipeline"},{"location":"developer_guide/backend/usage/#evaluater","text":"start with python3 main.py","title":"Evaluater"},{"location":"developer_guide/backend/usage/#api","text":"To run in IntelliJ follow the configuration in Development & Operations->Building and Deploying MathGrass->API","title":"API"},{"location":"developer_guide/frontend/","text":"General tba","title":"General"},{"location":"developer_guide/frontend/#general","text":"tba","title":"General"},{"location":"features/","text":"Teaching and Learning with MathGrass An Instructor's Perspective A Student's Perspective","title":"Teaching and Learning with MathGrass"},{"location":"features/#teaching-and-learning-with-mathgrass","text":"","title":"Teaching and Learning with MathGrass"},{"location":"features/#an-instructors-perspective","text":"","title":"An Instructor's Perspective"},{"location":"features/#a-students-perspective","text":"","title":"A Student's Perspective"}]}