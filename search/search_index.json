{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this Project MathGrass MathGrass ( Math ematical Gr aph Ass essment ) is a web application that brings automatic assessment to the realm of mathematical graphs. Its core functionality is the definition of graphs and tasks, which the system presents to participants. Tasks consist of form-based questions, graphical labeling, or questions which trigger the execution of a instructor-specified SageMath script. The participants can then interact with the graph in a graph viewer and try to answer the posed questions. Upon requesting an assessment of the individual answers, the assessment server evaluates the participants' answers and returns the results to the users. Furthermore, MathGrass supports incremental hints, which simulate instructor assistance and can support the learning experience. How to Read This Documentation This documentation contains the set of features that MathGrass provides, information about the usage for either instructors or students. Furthermore, there are notes about the deployment of a MathGrass instance and a developer documentation .","title":"About this Project"},{"location":"#about-this-project","text":"","title":"About this Project"},{"location":"#mathgrass","text":"MathGrass ( Math ematical Gr aph Ass essment ) is a web application that brings automatic assessment to the realm of mathematical graphs. Its core functionality is the definition of graphs and tasks, which the system presents to participants. Tasks consist of form-based questions, graphical labeling, or questions which trigger the execution of a instructor-specified SageMath script. The participants can then interact with the graph in a graph viewer and try to answer the posed questions. Upon requesting an assessment of the individual answers, the assessment server evaluates the participants' answers and returns the results to the users. Furthermore, MathGrass supports incremental hints, which simulate instructor assistance and can support the learning experience.","title":"MathGrass"},{"location":"#how-to-read-this-documentation","text":"This documentation contains the set of features that MathGrass provides, information about the usage for either instructors or students. Furthermore, there are notes about the deployment of a MathGrass instance and a developer documentation .","title":"How to Read This Documentation"},{"location":"deployment/","text":"Deployment tba","title":"Deployment"},{"location":"deployment/#deployment","text":"tba","title":"Deployment"},{"location":"developer_guide/architecture/","text":"Architecture The API and the Evaluator use RabbitMQ as a message bus to pass messages.","title":"Architecture"},{"location":"developer_guide/architecture/#architecture","text":"The API and the Evaluator use RabbitMQ as a message bus to pass messages.","title":"Architecture"},{"location":"developer_guide/openapi/","text":"OpenAPI Specification for MathGrass File Can be found in the backend project under mathgrass-api/openapi-spec/graphex-minimal.yaml Endpoints In the beginning of the file DTOs In the end of the file","title":"OpenAPI Specification for MathGrass"},{"location":"developer_guide/openapi/#openapi-specification-for-mathgrass","text":"","title":"OpenAPI Specification for MathGrass"},{"location":"developer_guide/openapi/#file","text":"Can be found in the backend project under mathgrass-api/openapi-spec/graphex-minimal.yaml","title":"File"},{"location":"developer_guide/openapi/#endpoints","text":"In the beginning of the file","title":"Endpoints"},{"location":"developer_guide/openapi/#dtos","text":"In the end of the file","title":"DTOs"},{"location":"developer_guide/quickstart/","text":"Quickstart Requirements Make sure that you have JDK>=17, Gradle, Docker, docker-compose, node>=18.12.0 with npm, and Python>=3.10 installed. Set Up Your Development Environment Clone the projects for the frontend , the API Project , and the evaluator project Start the dependencies of the API and the evaluator(PostGres & RabbitMQ) either manually or the provided docker compose project via docker-compose -f mathgrass-backend-infrastructure.yaml up -d in the folder mathgrass-server/api/docker Import the gradle project under mathgrass-api into your favorite Java IDE and run the application (entrypoint: MathgrassServerApplication.java ) with the Spring profile demodata (or not, if no demodata should be present). Import the React project under mathgrass-frontend into your favorite TypeScript IDE and run npm install && npm run start You can check whether the project has build correctly by checking the following paths on localhost: Swagger UI (http://localhost:8080/swagger-ui/) Frontend (http://localhost:3000)","title":"Quickstart"},{"location":"developer_guide/quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"developer_guide/quickstart/#requirements","text":"Make sure that you have JDK>=17, Gradle, Docker, docker-compose, node>=18.12.0 with npm, and Python>=3.10 installed.","title":"Requirements"},{"location":"developer_guide/quickstart/#set-up-your-development-environment","text":"Clone the projects for the frontend , the API Project , and the evaluator project Start the dependencies of the API and the evaluator(PostGres & RabbitMQ) either manually or the provided docker compose project via docker-compose -f mathgrass-backend-infrastructure.yaml up -d in the folder mathgrass-server/api/docker Import the gradle project under mathgrass-api into your favorite Java IDE and run the application (entrypoint: MathgrassServerApplication.java ) with the Spring profile demodata (or not, if no demodata should be present). Import the React project under mathgrass-frontend into your favorite TypeScript IDE and run npm install && npm run start You can check whether the project has build correctly by checking the following paths on localhost: Swagger UI (http://localhost:8080/swagger-ui/) Frontend (http://localhost:3000)","title":"Set Up Your Development Environment"},{"location":"developer_guide/backend/API_Implementation/","text":"API Implementation The API relies on generated interfaces based on the OpenAPI specification The Gradle task generateApi needs to be executed before being able to run the project When the API is started the swagger UI is available at http://localhost:8080/swagger-ui.html API und DB models are transformed to each other by classes that inherit from ModelTransformer under src/main/java/de/tudresden/inf/st/mathgrassserver/transform Endpoints are described in OpenAPI specification","title":"API Implementation"},{"location":"developer_guide/backend/API_Implementation/#api-implementation","text":"The API relies on generated interfaces based on the OpenAPI specification The Gradle task generateApi needs to be executed before being able to run the project When the API is started the swagger UI is available at http://localhost:8080/swagger-ui.html API und DB models are transformed to each other by classes that inherit from ModelTransformer under src/main/java/de/tudresden/inf/st/mathgrassserver/transform Endpoints are described in OpenAPI specification","title":"API Implementation"},{"location":"developer_guide/backend/concepts/","text":"Concepts & Domain DTO Model Generated by swagger codegen spec (see openapi-spec/graphex-minimal.yaml ) Entity Relationship Diagram (used in DB) Model Breakdown For better understanding of the model, we will break it down into a few parts: Task A Task describes a fully defined task on solving a problem on a certain graph. In order to distinguish between static tasks and dynamic tasks a task can (but does not necessarily have to) contain a TaskTemplate . If it contains a TaskTemplate, it can be considered a dynamic task otheriwse it's a static one (which is associated to a static answer string). A task template can be used in multiple tasks and it's purpose is providing the same exercise (with the same evaluation script) for different tasks (i.e. different graphs). This way the teacher can create one general task description, which can be associated with different graphs. For managing evaluation scripts there is the TaskSolver Students can submit Feedback for tasks. This feedback is not evaluated by the system, but can be used by the teacher to improve the task description. Teachers can setup TaskHints for tasks. These hints are shown to the student if he/she requests them individually. To group and categorize tasks, they can be put into TaskGroups and TaskCollections . A task can be part of multiple groups and collections. Graph Entities like Graph , Vertex and Edge obviuosly represent the graph data structure. Tags Tags can be used to categorize tasks and graphs. They are used in the frontend to filter task templates and graphs. TaskResult As soon as a student submits a solution to the API it gets recorded as a TaskResult in the database. After the solution has been checked/evaluated (using the static answer or the Evaluator service) the attribute answerTrue is written so that the TaskResult is complete.","title":"Concepts & Domain"},{"location":"developer_guide/backend/concepts/#concepts-domain","text":"","title":"Concepts &amp; Domain"},{"location":"developer_guide/backend/concepts/#dto-model","text":"Generated by swagger codegen spec (see openapi-spec/graphex-minimal.yaml )","title":"DTO Model"},{"location":"developer_guide/backend/concepts/#entity-relationship-diagram-used-in-db","text":"","title":"Entity Relationship Diagram (used in DB)"},{"location":"developer_guide/backend/concepts/#model-breakdown","text":"For better understanding of the model, we will break it down into a few parts:","title":"Model Breakdown"},{"location":"developer_guide/backend/concepts/#task","text":"A Task describes a fully defined task on solving a problem on a certain graph. In order to distinguish between static tasks and dynamic tasks a task can (but does not necessarily have to) contain a TaskTemplate . If it contains a TaskTemplate, it can be considered a dynamic task otheriwse it's a static one (which is associated to a static answer string). A task template can be used in multiple tasks and it's purpose is providing the same exercise (with the same evaluation script) for different tasks (i.e. different graphs). This way the teacher can create one general task description, which can be associated with different graphs. For managing evaluation scripts there is the TaskSolver Students can submit Feedback for tasks. This feedback is not evaluated by the system, but can be used by the teacher to improve the task description. Teachers can setup TaskHints for tasks. These hints are shown to the student if he/she requests them individually. To group and categorize tasks, they can be put into TaskGroups and TaskCollections . A task can be part of multiple groups and collections.","title":"Task"},{"location":"developer_guide/backend/concepts/#graph","text":"Entities like Graph , Vertex and Edge obviuosly represent the graph data structure.","title":"Graph"},{"location":"developer_guide/backend/concepts/#tags","text":"Tags can be used to categorize tasks and graphs. They are used in the frontend to filter task templates and graphs.","title":"Tags"},{"location":"developer_guide/backend/concepts/#taskresult","text":"As soon as a student submits a solution to the API it gets recorded as a TaskResult in the database. After the solution has been checked/evaluated (using the static answer or the Evaluator service) the attribute answerTrue is written so that the TaskResult is complete.","title":"TaskResult"},{"location":"developer_guide/backend/evaluator/","text":"Evaluator (Python) The Evaluator is a direct member of the Top Level Architecture and can be considered a microservice. It is responsible for the evaluation of submitted task solutions which are transferred by the API over the message bus. For isolation purposes it uses docker containers as computing instances for the actual evaluation process. Since the main purpose of this application is to evaluate mathematical tasks (especially tasks about graphs) every docker container used here is based on the Sage Math docker image. The basic configuration uses the BasicEvaluator (see below) in order to describe the procedure of the current evaluation process. Docker Manager ( docker_manager.py and docker_container.py ) The Docker Manager keeps track of allocated and free docker containers. Besided the preparation of the containers in advance it also removes them after they finished their respective evaluation request. As a result a docker container is only used for a single task solution evaluation. The reason behind that lays in the desired degree of isolation. In order to decrease latency when doing so it is possible to specify a constant which descibes how many docker containers should be prepared in advance. Also a maximum can be declared but if this limit is reached further requests will be discared for now. AbstractEvaluator ( abstract_evaluator.py ) The AbstractEvaluator contains an interface in order enable the implementation of different evaluation procedures. It is kept lean: First, every sub instance of the AbstractEvaluator can declare the name of the message bus queue which it will receive requests from. And second it defines a callback which is invoked when the evaluator receives a message from the selected queue. BasicEvaluator ( basic_evaluator.py ) Once the basic evaluator receives an evaluation request (containing a request id, a taks id and the submitted soluation) it will trigger a bunch of steps. These consist of the following: - allocating a container using the docker manager - loading the graph as well as the evaluation script from the database using the task id - base64 encoding the just loaded graph and the submitted solution - uploading the script as a file (named eval.sage) - executing the script in the container with command sage eval.sage <answer-as-base64> <graph-as-base64>","title":"Evaluator (Python)"},{"location":"developer_guide/backend/evaluator/#evaluator-python","text":"The Evaluator is a direct member of the Top Level Architecture and can be considered a microservice. It is responsible for the evaluation of submitted task solutions which are transferred by the API over the message bus. For isolation purposes it uses docker containers as computing instances for the actual evaluation process. Since the main purpose of this application is to evaluate mathematical tasks (especially tasks about graphs) every docker container used here is based on the Sage Math docker image. The basic configuration uses the BasicEvaluator (see below) in order to describe the procedure of the current evaluation process.","title":"Evaluator (Python)"},{"location":"developer_guide/backend/evaluator/#docker-manager-docker_managerpy-and-docker_containerpy","text":"The Docker Manager keeps track of allocated and free docker containers. Besided the preparation of the containers in advance it also removes them after they finished their respective evaluation request. As a result a docker container is only used for a single task solution evaluation. The reason behind that lays in the desired degree of isolation. In order to decrease latency when doing so it is possible to specify a constant which descibes how many docker containers should be prepared in advance. Also a maximum can be declared but if this limit is reached further requests will be discared for now.","title":"Docker Manager (docker_manager.py and docker_container.py)"},{"location":"developer_guide/backend/evaluator/#abstractevaluator-abstract_evaluatorpy","text":"The AbstractEvaluator contains an interface in order enable the implementation of different evaluation procedures. It is kept lean: First, every sub instance of the AbstractEvaluator can declare the name of the message bus queue which it will receive requests from. And second it defines a callback which is invoked when the evaluator receives a message from the selected queue.","title":"AbstractEvaluator (abstract_evaluator.py)"},{"location":"developer_guide/backend/evaluator/#basicevaluator-basic_evaluatorpy","text":"Once the basic evaluator receives an evaluation request (containing a request id, a taks id and the submitted soluation) it will trigger a bunch of steps. These consist of the following: - allocating a container using the docker manager - loading the graph as well as the evaluation script from the database using the task id - base64 encoding the just loaded graph and the submitted solution - uploading the script as a file (named eval.sage) - executing the script in the container with command sage eval.sage <answer-as-base64> <graph-as-base64>","title":"BasicEvaluator (basic_evaluator.py)"},{"location":"developer_guide/backend/prerequisites/","text":"Prerequisites & Requirements Message Bus Dependencies Rabbit MQ Database Dependencies Postgres Evaluator Dependencies Docker Python 3 API Dependencies Java 11 IntelliJ (recommended)","title":"Prerequisites & Requirements"},{"location":"developer_guide/backend/prerequisites/#prerequisites-requirements","text":"","title":"Prerequisites &amp; Requirements"},{"location":"developer_guide/backend/prerequisites/#message-bus","text":"","title":"Message Bus"},{"location":"developer_guide/backend/prerequisites/#dependencies","text":"Rabbit MQ","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#database","text":"","title":"Database"},{"location":"developer_guide/backend/prerequisites/#dependencies_1","text":"Postgres","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#evaluator","text":"","title":"Evaluator"},{"location":"developer_guide/backend/prerequisites/#dependencies_2","text":"Docker Python 3","title":"Dependencies"},{"location":"developer_guide/backend/prerequisites/#api","text":"","title":"API"},{"location":"developer_guide/backend/prerequisites/#dependencies_3","text":"Java 11 IntelliJ (recommended)","title":"Dependencies"},{"location":"developer_guide/backend/taskmanagement/","text":"Task Management Overview The task management is a core component of the backend. It is responsible for the management and execution of tasks. This page gives an overview over the functionality of the task management as well as some implementation details. Attention: This page refers to a client as the requester of a task evaluation. The client is in fact still part of the backend. It is basically an endpoint, which triggers the task execution and can be called by actual clients. General task execution process. The client sends a request to the task execution manager, which then evaluates submitted task, stores the result in the database and notifies the client. The client can then fetch the result from the database. Task Execution Since (especially dynamic) tasks may take a longer time to be processed, the task management was designed to be asynchronous. This means that the client does not need to wait for the task to be finished, but gets a task result id instead. The client can then use this id to check the status of the task. Once the task has been processed an event is emitted over an event bus to notify the client about the completion of the task, upon which the client can retrieve the result of the task. The task executor is able to process multiple tasks at the same time using multiple threads. Delayed Task Execution The process of requesting a task evaluation is asynchronous. First a task result is created, then a task is scheduled for execution and finally the task result ID is returned, which can then be used to register a listener for task completion. However, especially when requesting the evaluation of static tasks, the execution of the task evaluation might be called directly and post the task evaluation completion event before the listener could be registered. To solve this issue a custom DelayedTaskExecutor was implemented, which is able to delay the execution of the task evaluation. By adding a minimal delay of e.g. 50 ms the listener can be created before the task evaluation is finished in any circumstances. Task Queue The task management uses a task queue to limit and manage the number of tasks that are executed at the same time. This is necessary, since the evaluation of dynamic tasks requires the instantiation of Docker containers, which can be quite expensive. If the task executor has reached its maximum number of tasks, a new task request will be placed in the queue and will be executed as soon as a slot is available. Configuration The task manager can be configured with three parameters: - corePoolSize : Minimal number of threads kept alive in the thread pool. (Default: 1) - maxPoolSize : Maximum number of threads in the thread pool. (Default: 5) - queueCapacity : Maximum number of tasks that can be stored in the queue. (Default: Integer.MAX_VALUE) Note: The core pool size typically determines the number of tasks that can be executed in parallel. There are only new threads spawned if the number of tasks exceeds the core pool size. The maximum pool size determines the maximum number of threads that can be spawned in total. By default, the queueCapacity is set to a high number, so it is unlikely that threads are spawned than the core pool size. All parameters can be set in the application.properties file. Implementation Details Task Manager The task manager is implemented using Springs ThreadPoolTaskExecutor . It offers all necessary functionality to fit the requirements of the task management: - limit number of tasks executed at the same time -> limit number of spawned Docker containers - task queue to store tasks that cannot be executed at the moment - asynchronous task execution - easy to use in Spring applications Event Bus The event bus is implemented using Googles Guava EventBus . An alternative was using Springs integrated ApplicationEvents, which had the major problems of events shared between different threads. The advantage of the EventBus is that it is thread safe, allows to register multiple listeners for the same event and it is easier to use.","title":"Task Management"},{"location":"developer_guide/backend/taskmanagement/#task-management","text":"","title":"Task Management"},{"location":"developer_guide/backend/taskmanagement/#overview","text":"The task management is a core component of the backend. It is responsible for the management and execution of tasks. This page gives an overview over the functionality of the task management as well as some implementation details. Attention: This page refers to a client as the requester of a task evaluation. The client is in fact still part of the backend. It is basically an endpoint, which triggers the task execution and can be called by actual clients. General task execution process. The client sends a request to the task execution manager, which then evaluates submitted task, stores the result in the database and notifies the client. The client can then fetch the result from the database.","title":"Overview"},{"location":"developer_guide/backend/taskmanagement/#task-execution","text":"Since (especially dynamic) tasks may take a longer time to be processed, the task management was designed to be asynchronous. This means that the client does not need to wait for the task to be finished, but gets a task result id instead. The client can then use this id to check the status of the task. Once the task has been processed an event is emitted over an event bus to notify the client about the completion of the task, upon which the client can retrieve the result of the task. The task executor is able to process multiple tasks at the same time using multiple threads.","title":"Task Execution"},{"location":"developer_guide/backend/taskmanagement/#delayed-task-execution","text":"The process of requesting a task evaluation is asynchronous. First a task result is created, then a task is scheduled for execution and finally the task result ID is returned, which can then be used to register a listener for task completion. However, especially when requesting the evaluation of static tasks, the execution of the task evaluation might be called directly and post the task evaluation completion event before the listener could be registered. To solve this issue a custom DelayedTaskExecutor was implemented, which is able to delay the execution of the task evaluation. By adding a minimal delay of e.g. 50 ms the listener can be created before the task evaluation is finished in any circumstances.","title":"Delayed Task Execution"},{"location":"developer_guide/backend/taskmanagement/#task-queue","text":"The task management uses a task queue to limit and manage the number of tasks that are executed at the same time. This is necessary, since the evaluation of dynamic tasks requires the instantiation of Docker containers, which can be quite expensive. If the task executor has reached its maximum number of tasks, a new task request will be placed in the queue and will be executed as soon as a slot is available.","title":"Task Queue"},{"location":"developer_guide/backend/taskmanagement/#configuration","text":"The task manager can be configured with three parameters: - corePoolSize : Minimal number of threads kept alive in the thread pool. (Default: 1) - maxPoolSize : Maximum number of threads in the thread pool. (Default: 5) - queueCapacity : Maximum number of tasks that can be stored in the queue. (Default: Integer.MAX_VALUE) Note: The core pool size typically determines the number of tasks that can be executed in parallel. There are only new threads spawned if the number of tasks exceeds the core pool size. The maximum pool size determines the maximum number of threads that can be spawned in total. By default, the queueCapacity is set to a high number, so it is unlikely that threads are spawned than the core pool size. All parameters can be set in the application.properties file.","title":"Configuration"},{"location":"developer_guide/backend/taskmanagement/#implementation-details","text":"","title":"Implementation Details"},{"location":"developer_guide/backend/taskmanagement/#task-manager","text":"The task manager is implemented using Springs ThreadPoolTaskExecutor . It offers all necessary functionality to fit the requirements of the task management: - limit number of tasks executed at the same time -> limit number of spawned Docker containers - task queue to store tasks that cannot be executed at the moment - asynchronous task execution - easy to use in Spring applications","title":"Task Manager"},{"location":"developer_guide/backend/taskmanagement/#event-bus","text":"The event bus is implemented using Googles Guava EventBus . An alternative was using Springs integrated ApplicationEvents, which had the major problems of events shared between different threads. The advantage of the EventBus is that it is thread safe, allows to register multiple listeners for the same event and it is easier to use.","title":"Event Bus"},{"location":"developer_guide/backend/troubleshooting/","text":"Troubleshooting Starting the API The API won't start as long as there is no message queue reachable there is no database with speical name (see Development & Operations->Building and Deploying MathGrass->Database) created Starting the evaluator on Mac (especially with M1) If console says something like /opt/homebrew/opt/postgresql/lib/libpq.5.dylib' (no such file) : - run ln -s /opt/homebrew/opt/postgresql/lib/postgresql@14/* /opt/homebrew/opt/postgresql/lib/","title":"Troubleshooting"},{"location":"developer_guide/backend/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"developer_guide/backend/troubleshooting/#starting-the-api","text":"The API won't start as long as there is no message queue reachable there is no database with speical name (see Development & Operations->Building and Deploying MathGrass->Database) created","title":"Starting the API"},{"location":"developer_guide/backend/troubleshooting/#starting-the-evaluator-on-mac-especially-with-m1","text":"If console says something like /opt/homebrew/opt/postgresql/lib/libpq.5.dylib' (no such file) : - run ln -s /opt/homebrew/opt/postgresql/lib/postgresql@14/* /opt/homebrew/opt/postgresql/lib/","title":"Starting the evaluator on Mac (especially with M1)"},{"location":"developer_guide/backend/usage/","text":"How to Use MathGrass General process of MathGrass request/response interactions, basic workflow Launch Pipeline Deploy the components in the following order: Start postgres server Start rabbitmq server Run evaluator Run API Evaluater start with python3 main.py API To run in IntelliJ follow the configuration in Development & Operations->Building and Deploying MathGrass->API","title":"How to Use MathGrass"},{"location":"developer_guide/backend/usage/#how-to-use-mathgrass","text":"General process of MathGrass request/response interactions, basic workflow","title":"How to Use MathGrass"},{"location":"developer_guide/backend/usage/#launch-pipeline","text":"Deploy the components in the following order: Start postgres server Start rabbitmq server Run evaluator Run API","title":"Launch Pipeline"},{"location":"developer_guide/backend/usage/#evaluater","text":"start with python3 main.py","title":"Evaluater"},{"location":"developer_guide/backend/usage/#api","text":"To run in IntelliJ follow the configuration in Development & Operations->Building and Deploying MathGrass->API","title":"API"},{"location":"developer_guide/communication/communication/","text":"Frontend - Backend Communication Websockets Introduction Besides the REST endpoints generated as explained in the API implementation a major component of the frontend-backend communication is websockets. In short: Websockets are a way to establish a persistent connection between a websocket server and websocket clients. Messages can be exchanged in both directions, which allows for many use cases. However, establishing a connection is more complex than a simple HTTP request and comes with a larger overhead, which is why websockets is only used for only one case in the current implementation, which will be explained later. Websocket Server The websocket server is implemented using the Spring Websocket framework in the backend. The server is implemented as a Spring bean and is configured in the WebSocketConfig class. As with the current configuration, a connection can be established via ws://HOST-URL:8080/ws . Furthermore, there are two important entry points: * /app to send messages to the server * /topic to subscribe to channels and receive messages from the server The WebSocketController class is responsible for handling incoming messages and sending messages to the clients. Currently there are two endpoints: * /app/sendMessage to send a simple String message to the websocket server. This endpoint can be used for debugging purposes * /app/fetchAssessment to request the evaluation of a submitted task. This use case is explained further later on Websocket Client The websocket client is implemented in the frontend part of the application. To make the usage websockets easier a websocketService has been implemented. The service is responsible for managing the connection to the websocket server, as well as sending and receiving messages. The websocketService makes use of following libraries: * SockJS for connection management * webstomp-client for support of the STOMP protocol, which is used by the websocket server * RxJS for subscription/observer functionalities Task Evaluation Use Case Currently the only use case of using the websocket connection is to request the evaluation of a submitted task. Using a simple HTTP endpoint for the request would result in a longpolling solution, since the task evaluation might take a while. To avoid the frontend from blocking, the websocket connection is a great alternative. The websocket connection is only established in the assessment component. On creation of the component a connection to the websocket server is established. Once the component is unmounting the connection is closed again. Once a task has been submitted, a message containing the task ID and the submitted answer is sent to the websocket server. The server responds with a Task Result ID , which can be used to actually retrieve the result. For that the client subscribes to a channel for the respective task result ID. Once the server has finished the evaluation, the result is sent to the client by broadcasting the result to the respective channel. The client then unsubscribes from the channel and displays the result.","title":"Frontend - Backend Communication"},{"location":"developer_guide/communication/communication/#frontend-backend-communication","text":"","title":"Frontend - Backend Communication"},{"location":"developer_guide/communication/communication/#websockets-introduction","text":"Besides the REST endpoints generated as explained in the API implementation a major component of the frontend-backend communication is websockets. In short: Websockets are a way to establish a persistent connection between a websocket server and websocket clients. Messages can be exchanged in both directions, which allows for many use cases. However, establishing a connection is more complex than a simple HTTP request and comes with a larger overhead, which is why websockets is only used for only one case in the current implementation, which will be explained later.","title":"Websockets Introduction"},{"location":"developer_guide/communication/communication/#websocket-server","text":"The websocket server is implemented using the Spring Websocket framework in the backend. The server is implemented as a Spring bean and is configured in the WebSocketConfig class. As with the current configuration, a connection can be established via ws://HOST-URL:8080/ws . Furthermore, there are two important entry points: * /app to send messages to the server * /topic to subscribe to channels and receive messages from the server The WebSocketController class is responsible for handling incoming messages and sending messages to the clients. Currently there are two endpoints: * /app/sendMessage to send a simple String message to the websocket server. This endpoint can be used for debugging purposes * /app/fetchAssessment to request the evaluation of a submitted task. This use case is explained further later on","title":"Websocket Server"},{"location":"developer_guide/communication/communication/#websocket-client","text":"The websocket client is implemented in the frontend part of the application. To make the usage websockets easier a websocketService has been implemented. The service is responsible for managing the connection to the websocket server, as well as sending and receiving messages. The websocketService makes use of following libraries: * SockJS for connection management * webstomp-client for support of the STOMP protocol, which is used by the websocket server * RxJS for subscription/observer functionalities","title":"Websocket Client"},{"location":"developer_guide/communication/communication/#task-evaluation-use-case","text":"Currently the only use case of using the websocket connection is to request the evaluation of a submitted task. Using a simple HTTP endpoint for the request would result in a longpolling solution, since the task evaluation might take a while. To avoid the frontend from blocking, the websocket connection is a great alternative. The websocket connection is only established in the assessment component. On creation of the component a connection to the websocket server is established. Once the component is unmounting the connection is closed again. Once a task has been submitted, a message containing the task ID and the submitted answer is sent to the websocket server. The server responds with a Task Result ID , which can be used to actually retrieve the result. For that the client subscribes to a channel for the respective task result ID. Once the server has finished the evaluation, the result is sent to the client by broadcasting the result to the respective channel. The client then unsubscribes from the channel and displays the result.","title":"Task Evaluation Use Case"},{"location":"developer_guide/frontend/","text":"General tba","title":"General"},{"location":"developer_guide/frontend/#general","text":"tba","title":"General"},{"location":"developer_guide/frontend/testing/","text":"Testing Overview This page explains the testing set up, as well as the basic testing fundamentals used for testing the frontend. Frameworks Here are the two main frameworks used for testing JS code in general as well as React components: * Jest Main testing framework for JS/TS testing * Babel JavaScript compiler to compile Reacts JSX syntax to JavaScript Fundamentals Run all tests by executing following command in the root directory: npm test Test file names shouold follow following structure to be detected by jest: <NAME OF COMPONENT TO TEST>.test.<js/ts/jsx/tsx> Test files should be in the same directory as the component under test jest configuration file: https://github.com/MathGrass/mathgrass-frontend/blob/develop/jest.config.js babel configuration file: https://github.com/MathGrass/mathgrass-frontend/blob/develop/babel.config.json Testing with Redux Store A main aspect of the MathGrass Frontend application is the global redux store, which handles the applications state. There are two ways of testing with the redux store: * Work with a mocked store using redux-mock-store * Work with an instance of the real store In order to work with the real store some dispatch functions have been added to make testing easier (e.g. resetting the store). Examples So far only unit tests have been implemented. Examples of how to test React components can be seen in the test file for the assessment component . To see an example of how a service is tested have a look at the websocket service test .","title":"Testing"},{"location":"developer_guide/frontend/testing/#testing","text":"","title":"Testing"},{"location":"developer_guide/frontend/testing/#overview","text":"This page explains the testing set up, as well as the basic testing fundamentals used for testing the frontend.","title":"Overview"},{"location":"developer_guide/frontend/testing/#frameworks","text":"Here are the two main frameworks used for testing JS code in general as well as React components: * Jest Main testing framework for JS/TS testing * Babel JavaScript compiler to compile Reacts JSX syntax to JavaScript","title":"Frameworks"},{"location":"developer_guide/frontend/testing/#fundamentals","text":"Run all tests by executing following command in the root directory: npm test Test file names shouold follow following structure to be detected by jest: <NAME OF COMPONENT TO TEST>.test.<js/ts/jsx/tsx> Test files should be in the same directory as the component under test jest configuration file: https://github.com/MathGrass/mathgrass-frontend/blob/develop/jest.config.js babel configuration file: https://github.com/MathGrass/mathgrass-frontend/blob/develop/babel.config.json","title":"Fundamentals"},{"location":"developer_guide/frontend/testing/#testing-with-redux-store","text":"A main aspect of the MathGrass Frontend application is the global redux store, which handles the applications state. There are two ways of testing with the redux store: * Work with a mocked store using redux-mock-store * Work with an instance of the real store In order to work with the real store some dispatch functions have been added to make testing easier (e.g. resetting the store).","title":"Testing with Redux Store"},{"location":"developer_guide/frontend/testing/#examples","text":"So far only unit tests have been implemented. Examples of how to test React components can be seen in the test file for the assessment component . To see an example of how a service is tested have a look at the websocket service test .","title":"Examples"},{"location":"features/","text":"Teaching and Learning with MathGrass An Instructor's Perspective A Student's Perspective","title":"Teaching and Learning with MathGrass"},{"location":"features/#teaching-and-learning-with-mathgrass","text":"","title":"Teaching and Learning with MathGrass"},{"location":"features/#an-instructors-perspective","text":"","title":"An Instructor's Perspective"},{"location":"features/#a-students-perspective","text":"","title":"A Student's Perspective"}]}